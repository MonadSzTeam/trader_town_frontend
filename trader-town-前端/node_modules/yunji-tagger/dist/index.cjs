"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  DEFAULT_ATTRIBUTES: () => DEFAULT_ATTRIBUTES,
  ReactInjectorVitePlugin: () => react_injector_plugin_default,
  VueInjectorVitePlugin: () => vue_injector_plugin_default,
  createHTMLInjectorPlugin: () => html_injector_plugin_default
});
module.exports = __toCommonJS(index_exports);

// src/core/constants.ts
var DEFAULT_ATTRIBUTES = {
  uniqueId: "data-plugin-component-unique-id",
  filePath: "data-plugin-component-file-path",
  fileName: "data-plugin-component-file-name",
  startLocationNumber: "data-plugin-start-line-column",
  endLocationNumber: "data-plugin-end-line-column",
  tagName: "data-plugin-tag-name",
  tagContent: "data-plugin-tag-content",
  elementMap: "data-plugin-element-map",
  contextInfo: "data-plugin-component-context",
  hasElementChildren: "data-plugin-has-element-children",
  isSVG: "data-plugin-is-svg",
  svgWidth: "data-plugin-svg-width",
  svgHeight: "data-plugin-svg-height",
  svgContent: "data-plugin-svg-content"
};
var DEFAULT_INCLUDE_TAGS = [];
var DEFAULT_EXCLUDE_TAGS = [
  "script",
  "style",
  "template",
  "link",
  "meta",
  "html",
  "head",
  "body",
  "title",
  "base",
  "noscript",
  "noframes",
  "iframe",
  "frame",
  "frameset",
  "object",
  "embed",
  "applet",
  "Fragment"
];
var SVG_COMPONENT_MODULES = ["lucide-react", "@ant-design/icons"];
var DEFAULT_PLUGIN_OPTIONS = {
  // æ˜¯å¦å¯ç”¨æ’ä»¶
  enabled: true,
  // æ—¥å¿—çº§åˆ«
  logLevel: "warn",
  // çŽ¯å¢ƒè¿‡æ»¤
  env: process.env.NODE_ENV || "development",
  // æ˜¯å¦åœ¨å¼€å‘çŽ¯å¢ƒç¦ç”¨
  disableInDevelopment: false,
  // æ˜¯å¦åœ¨ç”Ÿäº§çŽ¯å¢ƒç¦ç”¨
  disableInProduction: true,
  // åŒ…å«çš„æ–‡ä»¶æ¨¡å¼
  include: [/\.vue$/, /\.(jsx|tsx)$/],
  // æŽ’é™¤çš„æ–‡ä»¶æ¨¡å¼
  exclude: [/node_modules/],
  // å±žæ€§é…ç½®
  attributes: { ...DEFAULT_ATTRIBUTES },
  // åŒ…å«çš„æ ‡ç­¾
  includeTags: [...DEFAULT_INCLUDE_TAGS],
  // æŽ’é™¤çš„æ ‡ç­¾
  excludeTags: [...DEFAULT_EXCLUDE_TAGS]
};

// src/vite/vue-injector-plugin.ts
var import_magic_string = __toESM(require("magic-string"), 1);
var import_pluginutils = require("@rollup/pluginutils");
var import_compiler_dom = require("@vue/compiler-dom");

// src/core/checkPeerDeps.ts
var import_module = require("module");
var import_path = __toESM(require("path"), 1);
function checkPeerDeps(packages, pluginName = "your-plugin") {
  const missing = [];
  const projectRoot = process.cwd();
  const projectRequire = (0, import_module.createRequire)(import_path.default.resolve(projectRoot, "index.js"));
  for (const pkg of packages) {
    try {
      const resolvedPath = projectRequire.resolve(pkg);
    } catch {
      missing.push(pkg);
    }
  }
  if (missing.length > 0) {
    throw new Error(
      `[${pluginName}] Missing peer dependencies:

  You need to install the following packages in your project:

    ${missing.map((name) => `- ${name}`).join("\n    ")}

  Run:

    npm install --save-dev ${missing.join(" ")}
`
    );
  }
}
var checkPeerDeps_default = checkPeerDeps;

// src/core/injectorVue.ts
var import_path2 = __toESM(require("path"), 1);
var VueElementType = 1;
var TagInjector = class {
  options = {};
  constructor(options = {}) {
    this.options = {
      ...DEFAULT_PLUGIN_OPTIONS,
      ...options,
      attributes: {
        ...DEFAULT_PLUGIN_OPTIONS.attributes,
        ...(options == null ? void 0 : options.attributes) || {}
      }
    };
  }
  // å¤„ç†Vue ASTèŠ‚ç‚¹
  processVueNode(node, context) {
    try {
      const { tag, loc, props: nodeProps } = node;
      const { filename, parentHasVFor } = context;
      const { includeTags, excludeTags, attributes } = this.options;
      if (excludeTags == null ? void 0 : excludeTags.includes(tag)) return "";
      if (includeTags && includeTags.length > 0 && !includeTags.includes(tag)) return "";
      let result = "";
      let additionJSON = {
        "data-plugin-language": "vue"
      };
      const projectRoot = process.cwd();
      const relativePath = import_path2.default.relative(projectRoot, filename);
      let thisNodeHasVFor = false;
      if (nodeProps.length > 0) {
        const elementMapAttr = attributes == null ? void 0 : attributes.elementMap;
        for (let itemProp of nodeProps) {
          if (itemProp.type === 7 && itemProp.name === "for") {
            thisNodeHasVFor = true;
            if (!additionJSON[elementMapAttr]) {
              additionJSON["data-plugin-component-for"] = "for";
              additionJSON[elementMapAttr] = "true";
            }
          }
        }
      }
      if (parentHasVFor && (attributes == null ? void 0 : attributes.elementMap)) {
        const elementMapAttr = attributes == null ? void 0 : attributes.elementMap;
        additionJSON[elementMapAttr] = "true";
      }
      if ((attributes == null ? void 0 : attributes.tagContent) && node.children && Array.isArray(node.children)) {
        const tagContent = attributes == null ? void 0 : attributes.tagContent;
        const hasElementChildrenAttr = attributes == null ? void 0 : attributes.hasElementChildren;
        const elementMapAttr = attributes == null ? void 0 : attributes.elementMap;
        if (Array.isArray(node.children)) {
          const elementChildren = node.children.filter((child) => child.type === VueElementType);
          if (elementChildren.length > 0) {
            additionJSON[hasElementChildrenAttr] = "true";
          } else {
            additionJSON[hasElementChildrenAttr] = "false";
          }
        }
        const content = this.extractVueTextContent(node.children);
        if (content && !additionJSON[tagContent]) {
          additionJSON[tagContent] = content;
        }
      }
      const uniqueIdAttr = attributes == null ? void 0 : attributes.uniqueId;
      if (uniqueIdAttr && !additionJSON[uniqueIdAttr]) {
        const uniqueId = `${relativePath}:${loc.start.line}:${loc.start.column}`;
        additionJSON[uniqueIdAttr] = uniqueId;
      }
      const filePathAttr = attributes == null ? void 0 : attributes.filePath;
      if (filePathAttr && !additionJSON[filePathAttr]) {
        additionJSON[filePathAttr] = relativePath || "unknown";
      }
      if (loc) {
        const { line: startLine, column: startColumn } = loc.start;
        const { line: endLine, column: endColumn } = loc.end;
        const startLocationNumberAttr = attributes == null ? void 0 : attributes.startLocationNumber;
        if (startLocationNumberAttr && !additionJSON[startLocationNumberAttr]) {
          additionJSON[startLocationNumberAttr] = `${startLine}:${startColumn}`.toString();
        }
        const endLocationNumberAttr = attributes == null ? void 0 : attributes.endLocationNumber;
        if (endLocationNumberAttr && !additionJSON[endLocationNumberAttr]) {
          additionJSON[endLocationNumberAttr] = `${endLine}:${endColumn}`.toString();
        }
      }
      const tagNameAttr = attributes == null ? void 0 : attributes.tagName;
      if ((attributes == null ? void 0 : attributes.tagName) && !additionJSON[tagNameAttr]) {
        additionJSON[tagNameAttr] = tag;
      }
      if ((attributes == null ? void 0 : attributes.custom) && additionJSON[attributes == null ? void 0 : attributes.custom]) {
        Object.entries(attributes == null ? void 0 : attributes.custom).forEach(([name, value]) => {
          additionJSON[attributes[name]] = value;
        });
      }
      for (const [name, value] of Object.entries(additionJSON)) {
        result += ` ${name}="${encodeURIComponent(value)}"`;
      }
      return result;
    } catch (error) {
      console.error("error", error);
      return "";
    }
  }
  // æå– Vue AST èŠ‚ç‚¹ä¸­çš„æ–‡æœ¬å†…å®¹
  extractVueTextContent(children) {
    const textParts = children.map((child) => {
      var _a;
      if (child.type === 2) {
        return child.content.trim();
      } else if (child.type === 5 && ((_a = child.content) == null ? void 0 : _a.type) === 4) {
        return `{{${child.content.content}}}`;
      }
      return "";
    });
    return textParts.filter(Boolean).join(" ").trim();
  }
  // æ³¨å…¥æ‰€æœ‰å­å…ƒç´ 
  injectChildren(node, filename, parentHasVFor, s) {
    if (Array.isArray(node.children)) {
      for (const child of node.children) {
        if (child.type === VueElementType) {
          const insertPosition = child.loc.start.offset + child.tag.length + 1;
          const addition = this.processVueNode(child, {
            filename,
            parentHasVFor
          });
          s.prependLeft(insertPosition, addition);
          this.injectChildren(child, filename, parentHasVFor, s);
        }
      }
    }
  }
};
var injectorVue_default = TagInjector;

// src/vite/vue-injector-plugin.ts
var VueElementType2 = 1;
var createVueInjectorPlugin = (options = {}) => {
  checkPeerDeps_default(["@rollup/pluginutils", "@vue/compiler-dom", "@rollup/pluginutils", "magic-string"], "yunji-tagger");
  const filter = (0, import_pluginutils.createFilter)(options.include || /\.vue$/, options.exclude || /node_modules/);
  const injector = new injectorVue_default(options);
  let shouldGenerateSourcemap = true;
  return {
    name: "vite-vue-yunji-tagger",
    enforce: "pre",
    // åœ¨é…ç½®è§£æžåŽèŽ·å– sourcemap è®¾ç½®
    configResolved(config) {
      shouldGenerateSourcemap = config.command === "serve" || config.build && config.build.sourcemap;
    },
    transform(code, id) {
      if (!filter(id)) return;
      try {
        let prefixSubstring = "", suffixSubstring = "";
        const s = new import_magic_string.default(code);
        const ast = (0, import_compiler_dom.parse)(code, {
          comments: true
        });
        const templateNode = ast.children.find(
          (node) => node.type === VueElementType2 && node.tag === "template"
        );
        (0, import_compiler_dom.transform)(ast, {
          nodeTransforms: [
            (node) => {
              if (node.type === VueElementType2) {
                const insertPosition = node.loc.start.offset + node.tag.length + 1;
                const addition = injector.processVueNode(node, {
                  filename: id,
                  parentHasVFor: false
                  // é¡¶å±‚é»˜è®¤æ—  v-for
                });
                s.prependLeft(insertPosition, addition);
              }
            }
          ]
        });
        let result = s.toString();
        const ss = s.toString().slice(prefixSubstring.length, result.length - suffixSubstring.length);
        return {
          code: result,
          map: null
        };
      } catch (error) {
        console.error(`[vite-vue-yunji-tagger] Error processing ${id}:`);
        return null;
      }
    }
  };
};
var vue_injector_plugin_default = createVueInjectorPlugin;

// src/vite/react-injector-plugin.ts
var import_core2 = require("@babel/core");
var import_pluginutils2 = require("@rollup/pluginutils");

// src/core/injectorReact.ts
var import_path3 = __toESM(require("path"), 1);
var import_core = require("@babel/core");
var TagInjector2 = class {
  options = {};
  constructor(options = {}) {
    this.options = {
      ...DEFAULT_PLUGIN_OPTIONS,
      ...options,
      attributes: {
        ...DEFAULT_PLUGIN_OPTIONS.attributes,
        ...(options == null ? void 0 : options.attributes) || {}
      }
    };
  }
  // å¤„ç†React JSXèŠ‚ç‚¹
  processReactNode(node, state) {
    var _a, _b, _c, _d, _e;
    if (node.__tag_injected__) return;
    Object.defineProperty(node, "__tag_injected__", {
      value: true,
      enumerable: false
    });
    const isJSXElement = node.type === "JSXElement";
    const openingEl = isJSXElement ? node.openingElement : node;
    const loc = openingEl.loc;
    const { filename, root } = state.file.opts;
    const tagName = ((_a = openingEl.name) == null ? void 0 : _a.name) || "";
    const { includeTags, excludeTags, attributes } = this.options;
    if (excludeTags == null ? void 0 : excludeTags.includes(tagName)) return;
    if (includeTags && (includeTags == null ? void 0 : includeTags.length) > 0 && !(includeTags == null ? void 0 : includeTags.includes(tagName)))
      return;
    const newAttributes = [];
    const newAttrNames = /* @__PURE__ */ new Set();
    const existingAttrNames = new Set(
      openingEl.attributes.filter((attr) => attr.type === "JSXAttribute").map((attr) => {
        var _a2;
        return (_a2 = attr.name) == null ? void 0 : _a2.name;
      })
    );
    const safeAddAttr = (name, value) => {
      if (!name || newAttrNames.has(name)) return;
      const alreadyExists = openingEl.attributes.some((attr) => {
        var _a2, _b2;
        if (attr.type === "JSXAttribute" && ((_a2 = attr.name) == null ? void 0 : _a2.name) === name) {
          return true;
        }
        if (attr.type === "JSXSpreadAttribute" && ((_b2 = attr.argument) == null ? void 0 : _b2.type) === "ObjectExpression") {
          return attr.argument.properties.some((prop) => {
            if (prop.type !== "ObjectProperty") return false;
            const key = prop.key;
            return key.type === "Identifier" && key.name === name || key.type === "StringLiteral" && key.value === name;
          });
        }
        return false;
      });
      if (alreadyExists) return;
      newAttributes.push(this.createJSXAttribute(name, value));
      newAttrNames.add(name);
    };
    safeAddAttr("data-plugin-language", "react");
    const isSvgTag = this.isSVGElement(openingEl);
    const insideSvg = (state == null ? void 0 : state.path) ? this.isInsideSVG(state.path) : false;
    const isSvgComponent = (state == null ? void 0 : state.path) ? this.isSVGComponent(openingEl, state.path) : false;
    if (isSvgTag || insideSvg || isSvgComponent) {
      safeAddAttr("data-plugin-is-svg", "true");
      const dims = this.getSvgDimensions(openingEl, state == null ? void 0 : state.path);
      if ((attributes == null ? void 0 : attributes.svgWidth) && (dims == null ? void 0 : dims.width) != null) {
        safeAddAttr(
          attributes.svgWidth,
          encodeURIComponent(String(dims.width))
        );
      }
      if ((attributes == null ? void 0 : attributes.svgHeight) && (dims == null ? void 0 : dims.height) != null) {
        safeAddAttr(
          attributes.svgHeight,
          encodeURIComponent(String(dims.height))
        );
      }
      if (attributes == null ? void 0 : attributes.svgContent) {
        const sourceCode = state.file.code.slice(node.start, node.end);
        safeAddAttr(attributes.svgContent, encodeURIComponent(sourceCode));
      }
    }
    if ((attributes == null ? void 0 : attributes.tagContent) && isJSXElement) {
      const content = this.extractTextContent(node);
      if (content) {
        safeAddAttr(attributes.tagContent, encodeURIComponent(content));
      }
    }
    const relativePath = import_path3.default.relative(root, filename);
    const fileName = import_path3.default.basename(filename);
    safeAddAttr(
      attributes == null ? void 0 : attributes.filePath,
      encodeURIComponent(relativePath || "unknown")
    );
    safeAddAttr(attributes == null ? void 0 : attributes.fileName, encodeURIComponent(fileName));
    if (loc) {
      const { line: startLine, column: startColumn } = loc.start;
      let endLine = loc.end.line;
      let endColumn = loc.end.column;
      if (isJSXElement && ((_c = (_b = node.closingElement) == null ? void 0 : _b.loc) == null ? void 0 : _c.end)) {
        endLine = node.closingElement.loc.end.line;
        endColumn = node.closingElement.loc.end.column;
      }
      if (attributes == null ? void 0 : attributes.uniqueId) {
        const uniqueId = `${relativePath}:${startLine}:${startColumn}:${endLine}:${endColumn}`;
        safeAddAttr(attributes == null ? void 0 : attributes.uniqueId, encodeURIComponent(uniqueId));
      }
      safeAddAttr(
        attributes == null ? void 0 : attributes.startLocationNumber,
        encodeURIComponent(`${startLine}:${startColumn}`)
      );
      safeAddAttr(
        attributes == null ? void 0 : attributes.endLocationNumber,
        encodeURIComponent(`${endLine}:${endColumn}`)
      );
    }
    safeAddAttr(attributes == null ? void 0 : attributes.tagName, tagName);
    if (attributes == null ? void 0 : attributes.contextInfo) {
      const context = this.extractContextInfo(openingEl, state);
      if (context) {
        safeAddAttr(
          attributes.contextInfo,
          encodeURIComponent(JSON.stringify(context))
        );
      }
    }
    for (const attr of openingEl.attributes) {
      if (attr.type === "JSXAttribute" && ((_d = attr.name) == null ? void 0 : _d.name) === "key") {
        safeAddAttr(attributes.elementMap, "map");
        break;
      }
    }
    if ((state == null ? void 0 : state.path) && this.isJSXFromMap(state.path)) {
      safeAddAttr(attributes.elementMap, "map");
    }
    if (isJSXElement && (attributes == null ? void 0 : attributes.hasElementChildren)) {
      const hasElementChildren = (_e = node.children) == null ? void 0 : _e.some(
        (child) => child.type === "JSXElement" || child.type === "JSXFragment"
      );
      safeAddAttr(attributes.hasElementChildren, String(hasElementChildren));
    }
    if (attributes == null ? void 0 : attributes.custom) {
      Object.entries(attributes.custom).forEach(([name, value]) => {
        safeAddAttr(name, encodeURIComponent(value));
      });
    }
    const firstSpreadIndex = openingEl.attributes.findIndex(
      (attr) => attr.type === "JSXSpreadAttribute"
    );
    if (firstSpreadIndex === -1) {
      openingEl.attributes.push(...newAttributes);
    } else {
      openingEl.attributes.splice(firstSpreadIndex, 0, ...newAttributes);
    }
  }
  // æå–ä¸Šä¸‹æ–‡ä¿¡æ¯çš„è¾…åŠ©æ–¹æ³•
  extractContextInfo(node) {
    const context = {};
    const attributes = node.attributes.reduce((acc, attr) => {
      var _a, _b, _c;
      const attrName = (_a = attr == null ? void 0 : attr.name) == null ? void 0 : _a.name;
      if (attr.type === "JSXAttribute") {
        if (((_b = attr.value) == null ? void 0 : _b.type) === "StringLiteral") {
          acc[attrName] = attr.value.value;
        } else if (((_c = attr.value) == null ? void 0 : _c.type) === "JSXExpressionContainer") {
          if (attr.value.expression.type === "StringLiteral") {
            acc[attrName] = attr.value.expression.value;
          } else if (attr.value.expression.type === "ConditionalExpression") {
            acc[attr.value.expression.type] = attrName;
            acc[`${attrName}-consequent`] = attr.value.expression.consequent.value;
            acc[`${attrName}-alternate`] = attr.value.expression.alternate.value;
          }
        }
      }
      return acc;
    }, {});
    if (attributes.placeholder) {
      context.placeholder = attributes.placeholder;
    }
    if (attributes.className) {
      context.className = attributes.className;
    }
    if (attributes.id) {
      context.id = attributes.id;
    }
    if (attributes.href) {
      context.href = attributes.href;
    }
    if (attributes.src) {
      context.src = attributes.src;
    }
    if (attributes.ConditionalExpression) {
      context[`${attributes.ConditionalExpression}-consequent`] = attributes[`${attributes.ConditionalExpression}-consequent`];
      context[`${attributes.ConditionalExpression}-alternate`] = attributes[`${attributes.ConditionalExpression}-alternate`];
      context[`ConditionalExpression`] = attributes.ConditionalExpression;
    }
    return Object.keys(context).length > 0 ? context : null;
  }
  // æå–æ–‡æœ¬å†…å®¹çš„è¾…åŠ©æ–¹æ³•
  extractTextContent(node) {
    if (!node.children || !Array.isArray(node.children)) return "";
    const textParts = node.children.map((child) => {
      if (child.type === "JSXText") {
        return child.value.trim();
      } else if (child.type === "JSXExpressionContainer") {
        if (child.expression.type === "StringLiteral") {
          return child.expression.value;
        }
      }
      return "";
    }).filter(Boolean);
    return textParts.join(" ").trim();
  }
  // åˆ›å»ºJSXå±žæ€§
  createJSXAttribute(name, value) {
    return import_core.types.jsxAttribute(
      import_core.types.jsxIdentifier(name),
      import_core.types.stringLiteral(value)
    );
  }
  isSVGElement(openingEl) {
    const nameNode = openingEl == null ? void 0 : openingEl.name;
    if (!nameNode) return false;
    if (nameNode.type === "JSXIdentifier") {
      const n = nameNode.name;
      return n === "svg" || [
        "g",
        "path",
        "circle",
        "rect",
        "line",
        "polyline",
        "polygon",
        "text",
        "defs",
        "clipPath",
        "linearGradient",
        "radialGradient",
        "stop",
        "use",
        "symbol",
        "marker",
        "pattern",
        "mask"
      ].includes(n);
    }
    return false;
  }
  isInsideSVG(path4) {
    var _a, _b;
    let p = path4;
    while (p) {
      if (p.isJSXElement && p.isJSXElement()) {
        const name = (_b = (_a = p.node) == null ? void 0 : _a.openingElement) == null ? void 0 : _b.name;
        if (name && name.type === "JSXIdentifier" && name.name === "svg") {
          return true;
        }
      }
      p = p.parentPath;
    }
    return false;
  }
  isSVGComponent(openingEl, path4) {
    var _a, _b, _c, _d, _e, _f;
    const nameNode = openingEl == null ? void 0 : openingEl.name;
    if (!nameNode || nameNode.type !== "JSXIdentifier") return false;
    const compName = nameNode.name;
    const binding = (_b = (_a = path4 == null ? void 0 : path4.scope) == null ? void 0 : _a.getBinding) == null ? void 0 : _b.call(_a, compName);
    if (!binding) return false;
    const bpath = binding.path;
    if (!bpath || !(((_c = bpath.isImportSpecifier) == null ? void 0 : _c.call(bpath)) || ((_d = bpath.isImportDefaultSpecifier) == null ? void 0 : _d.call(bpath)) || ((_e = bpath.isImportNamespaceSpecifier) == null ? void 0 : _e.call(bpath)))) {
      return false;
    }
    const importDecl = bpath.parent;
    const source = ((_f = importDecl == null ? void 0 : importDecl.source) == null ? void 0 : _f.value) || "";
    if (typeof source !== "string") return false;
    if (SVG_COMPONENT_MODULES.includes(source)) return true;
    if (source.startsWith("react-icons")) return true;
    return false;
  }
  getSvgDimensions(openingEl, path4) {
    const getAttr = (name) => openingEl.attributes.find(
      (a) => {
        var _a;
        return a.type === "JSXAttribute" && ((_a = a.name) == null ? void 0 : _a.name) === name;
      }
    );
    const readVal = (attr) => {
      var _a, _b;
      if (!attr) return void 0;
      if (((_a = attr.value) == null ? void 0 : _a.type) === "StringLiteral") return attr.value.value;
      if (((_b = attr.value) == null ? void 0 : _b.type) === "JSXExpressionContainer") {
        const e = attr.value.expression;
        if ((e == null ? void 0 : e.type) === "StringLiteral") return e.value;
        if ((e == null ? void 0 : e.type) === "NumericLiteral") return e.value;
      }
      return void 0;
    };
    const readStyleDims = (attr) => {
      var _a, _b;
      let w, h, fs;
      if (((_a = attr == null ? void 0 : attr.value) == null ? void 0 : _a.type) === "JSXExpressionContainer" && ((_b = attr.value.expression) == null ? void 0 : _b.type) === "ObjectExpression") {
        for (const prop of attr.value.expression.properties || []) {
          if (prop.type !== "ObjectProperty") continue;
          const key = prop.key;
          const k = key.type === "Identifier" ? key.name : key.type === "StringLiteral" ? key.value : void 0;
          if (!k) continue;
          const v = prop.value;
          if (v.type === "StringLiteral") {
            if (k === "width") w = v.value;
            if (k === "height") h = v.value;
            if (k === "fontSize") fs = v.value;
          } else if (v.type === "NumericLiteral") {
            if (k === "width") w = v.value;
            if (k === "height") h = v.value;
            if (k === "fontSize") fs = v.value;
          }
        }
      }
      if ((w == null || h == null) && fs != null) {
        if (w == null) w = fs;
        if (h == null) h = fs;
      }
      return { width: w, height: h };
    };
    let width = readVal(getAttr("width"));
    let height = readVal(getAttr("height"));
    if (width == null || height == null) {
      const styleDims = readStyleDims(getAttr("style"));
      if (width == null) width = styleDims.width;
      if (height == null) height = styleDims.height;
    }
    if (width == null || height == null) {
      const size = readVal(getAttr("size"));
      if (size != null) {
        if (width == null) width = size;
        if (height == null) height = size;
      }
    }
    return { width, height };
  }
  isJSXFromMap(path4) {
    var _a, _b, _c;
    let parentPath = path4.parentPath;
    while (parentPath) {
      if (parentPath.isCallExpression() && ((_c = (_b = (_a = parentPath.node) == null ? void 0 : _a.callee) == null ? void 0 : _b.property) == null ? void 0 : _c.name) === "map") {
        return true;
      }
      parentPath = parentPath.parentPath;
    }
    return false;
  }
};
var injectorReact_default = TagInjector2;

// src/babel/react-plugin.ts
var ReactBabelPlugin = (babel) => {
  const { types: t } = babel;
  return {
    name: "babel-react-yunji-tagger",
    visitor: {
      JSXAttribute(path4) {
        var _a;
        if (!((_a = path4.node) == null ? void 0 : _a.name)) return;
        let attributeName;
        if (path4.node.name.type === "JSXIdentifier") {
          attributeName = path4.node.name.name;
        } else if (path4.node.name.type === "JSXNamespacedName") {
          attributeName = `${path4.node.name.namespace.name}:${path4.node.name.name.name}`;
        } else {
          return;
        }
        if (attributeName.includes(":")) {
          const camelCaseName = attributeName.split(":").map((part, i) => i > 0 ? part.charAt(0).toUpperCase() + part.slice(1) : part).join("");
          path4.node.name = {
            type: "JSXIdentifier",
            name: camelCaseName
          };
        }
      },
      // å¤„ç† JSXElement èŠ‚ç‚¹
      JSXElement(path4, state) {
        const { injector } = state.opts;
        if (!injector) return;
        injector.processReactNode(path4.node, {
          ...state,
          path: path4
          // ðŸ‘ˆ æŠŠå½“å‰ path ä¼ è¿›åŽ»
        });
      },
      JSXOpeningElement(path4, state) {
        const { injector } = state.opts;
        if (!injector) return;
        injector.processReactNode(path4.node, {
          ...state,
          path: path4
          // ðŸ‘ˆ æŠŠå½“å‰ path ä¼ è¿›åŽ»
        });
      }
    }
  };
};
var react_plugin_default = ReactBabelPlugin;

// src/vite/react-injector-plugin.ts
var createReactInjectorPlugin = (options = {}) => {
  checkPeerDeps_default(["@babel/preset-typescript", "@babel/preset-react", "@babel/core"], "yunji-tagger");
  const filter = (0, import_pluginutils2.createFilter)(options.include || /\.(jsx|tsx)$/, options.exclude || /node_modules/);
  const injector = new injectorReact_default(options);
  return {
    name: "vite-react-yunji-tagger",
    enforce: "pre",
    async transform(code, id) {
      if (!filter(id)) return;
      try {
        const result = await (0, import_core2.transformAsync)(code, {
          filename: id,
          presets: [
            [
              "@babel/preset-typescript",
              {
                isTSX: true,
                allExtensions: true,
                parserOpts: {
                  throwIfNamespace: false
                }
              }
            ],
            ["@babel/preset-react", { runtime: "automatic" }]
          ],
          parserOpts: {
            throwIfNamespace: false
          },
          plugins: [
            // function taggerPlugin() {
            //   return {
            //     visitor: {
            //       JSXOpeningElement(path: any, state: any) {
            //         const name = path.node.name;
            //         if (name.type === 'JSXIdentifier' && name.name !== 'Fragment') {
            //           path.node.attributes.push({
            //             type: 'JSXAttribute',
            //             name: { type: 'JSXIdentifier', name: 'data-test' },
            //             value: { type: 'StringLiteral', value: 'injected' },
            //           });
            //         }
            //         // injector.processReactNode(path.node, state);
            //       },
            //     },
            //   };
            // },
            [react_plugin_default, { injector }]
          ],
          ast: true,
          code: true,
          babelrc: false,
          configFile: false
        });
        return {
          code: (result == null ? void 0 : result.code) || code,
          map: (result == null ? void 0 : result.map) || null
        };
      } catch (error) {
        console.error(`[vite-react-yunji-tagger] Error processing ${id}:`);
        return null;
      }
    }
  };
};
var react_injector_plugin_default = createReactInjectorPlugin;

// src/vite/html-injector-plugin.ts
function toDatasetKey(dataAttr, charText = "-") {
  return dataAttr.replace(/^data-/, "").split(charText).map((part, index) => index === 0 ? part : part.charAt(0).toUpperCase() + part.slice(1)).join("");
}
function getCurrentFileName() {
  const url = window.location.href;
  const path4 = new URL(url).pathname;
  const segments = path4.split("/");
  const fileName = segments[segments.length - 1];
  return fileName || "index.html";
}
function getLineAndColumn(element) {
  const html = document.documentElement.outerHTML;
  const elementHtml = element.outerHTML;
  const index = html.indexOf(elementHtml);
  if (index === -1) {
    return { line: 0, column: 0, endLine: 0, endColumn: 0 };
  }
  const linesBefore = html.substring(0, index).split("\n");
  const startLine = linesBefore.length;
  const startColumn = linesBefore[linesBefore.length - 1].length + 1;
  const endIndex = index + elementHtml.length;
  const linesToEnd = html.substring(0, endIndex).split("\n");
  const endLine = linesToEnd.length;
  const endColumn = linesToEnd[linesToEnd.length - 1].length + 1;
  return { startLine, startColumn, endLine, endColumn };
}
function createHTMLInjectorPlugin() {
  const fileName = getCurrentFileName();
  const elements = document.body.querySelectorAll("*");
  elements.forEach((element) => {
    try {
      const { startLine, startColumn, endLine, endColumn } = getLineAndColumn(element);
      const tagName = element.tagName.toLowerCase();
      const id = element.id || "\u65E0";
      const className = element.className || "\u65E0";
      const childCount = element.children.length;
      const elementInfo = {};
      elementInfo[DEFAULT_ATTRIBUTES["uniqueId"]] = encodeURIComponent(
        `${fileName}:${startLine}:${startColumn}:${endLine}:${endColumn}`
      );
      elementInfo[DEFAULT_ATTRIBUTES["filePath"]] = encodeURIComponent(`${fileName}`);
      elementInfo[DEFAULT_ATTRIBUTES["fileName"]] = encodeURIComponent(`${fileName}`);
      elementInfo[DEFAULT_ATTRIBUTES["startLocationNumber"]] = encodeURIComponent(`${startLine}:${startColumn}`);
      elementInfo[DEFAULT_ATTRIBUTES["endLocationNumber"]] = encodeURIComponent(`${endLine}:${endColumn}`);
      elementInfo[DEFAULT_ATTRIBUTES["tagName"]] = encodeURIComponent(tagName);
      for (const key in elementInfo) {
        const datasetKey = toDatasetKey(key);
        if ("dataset" in element) {
          element.dataset[datasetKey] = elementInfo[key];
        }
      }
    } catch (error) {
      console.error("Error processing element:", error);
    }
  });
}
var html_injector_plugin_default = createHTMLInjectorPlugin;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_ATTRIBUTES,
  ReactInjectorVitePlugin,
  VueInjectorVitePlugin,
  createHTMLInjectorPlugin
});
//# sourceMappingURL=index.cjs.map